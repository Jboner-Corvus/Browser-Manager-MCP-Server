import{describe as e,it as o,expect as t,beforeEach as a,afterEach as i}from"vitest";vi.mock("./logger.js");import{FastMCP as s}from"fastmcp";import{config as n}from"./config.js";import{applicationEntryPoint as r,authHandler as c}from"./server.js";import l from"./logger.js";const m=vi.mocked(l,!0);vi.mock("fastmcp"),vi.mock("./config.js"),vi.mock("./tools/debugContext.tool.js"),vi.mock("./tools/longProcess.tool.js"),vi.mock("./tools/synchronousExample.tool.js"),vi.mock("./queue.js",()=>({initQueues:vi.fn(()=>({taskQueue:{name:"mock-task-queue"},deadLetterQueue:{name:"mock-dead-letter-queue"},redisConnection:{host:"mock-redis"}}))})),vi.mock("crypto",async e=>({...await e(),randomUUID:vi.fn(()=>"mock-uuid")})),e("Server Tests",()=>{let l,d;a(()=>{vi.clearAllMocks(),vi.spyOn(process,"on").mockImplementation((e,o)=>("SIGTERM"===e&&(d=o),process)),vi.spyOn(process,"exit").mockImplementation(()=>{throw new Error("process.exit called")});const e={info:vi.fn(),warn:vi.fn(),error:vi.fn(),fatal:vi.fn(),child:vi.fn()};m.child.mockReturnValue(e),m.info.mockImplementation(e.info),m.warn.mockImplementation(e.warn),m.fatal.mockImplementation(e.fatal),d=void 0,l={on:vi.fn(),addTool:vi.fn(),start:vi.fn(),stop:vi.fn()},vi.mocked(s).mockImplementation(()=>l),vi.mocked(n).AUTH_TOKEN="test-token",vi.mocked(n).PORT=3e3,vi.mocked(n).HEALTH_CHECK_PATH="/health",vi.mocked(n).NODE_ENV="test"}),i(()=>{vi.restoreAllMocks(),vi.resetModules()}),e("authHandler",()=>{o("should authenticate successfully",async()=>{const e=await c({headers:{authorization:"Bearer test-token"},socket:{remoteAddress:"127.0.0.1"}});t(e).toBeDefined(),t(m.child({}).info).toHaveBeenCalledWith({authId:"mock-uuid"},"Authentification réussie.")}),o("should fail for missing auth header",async()=>{await t(c({headers:{},socket:{remoteAddress:"127.0.0.1"}})).rejects.toThrow("Accès non autorisé"),t(m.child({}).warn).toHaveBeenCalledWith({clientIp:"127.0.0.1"},"Tentative d'accès non autorisé: en-tête 'Authorization' manquant ou invalide.")})}),e("applicationEntryPoint",()=>{o("should start the server",async()=>{await r(),t(l.start).toHaveBeenCalled()}),o("should handle startup failure",async()=>{l.start.mockRejectedValue(new Error("Startup failed")),await t(r()).rejects.toThrow("process.exit called"),t(m.fatal).toHaveBeenCalled()}),o("should handle SIGTERM",async()=>{if(await r(),t(d).toBeDefined(),!d)throw new Error("sigtermHandler not defined");l.stop.mockResolvedValue(void 0),await t(d()).rejects.toThrow("process.exit called"),t(l.stop).toHaveBeenCalled()})})});